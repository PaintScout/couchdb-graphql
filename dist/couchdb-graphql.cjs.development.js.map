{"version":3,"file":"couchdb-graphql.cjs.development.js","sources":["../src/graphql/base.ts","../src/createContext.ts","../src/util/createResolverFunction.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/util/parseFetchResponse.ts","../src/util/resolveConflicts.ts","../src/couchdb/put.ts","../src/graphql/mutations/put.ts","../src/couchdb/bulkDocs.ts","../src/graphql/mutations/bulkDocs.ts","../src/couchdb/allDocs.ts","../src/graphql/queries/allDocs.ts","../src/couchdb/bulkGet.ts","../src/graphql/queries/bulkGet.ts","../src/couchdb/changes.ts","../src/graphql/queries/changes.ts","../src/couchdb/find.ts","../src/couchdb/get.ts","../src/couchdb/info.ts","../src/couchdb/query.ts","../src/couchdb/search.ts","../src/graphql/queries/find.ts","../src/graphql/queries/get.ts","../src/graphql/queries/info.ts","../src/graphql/queries/query.ts","../src/graphql/queries/search.ts","../src/createCouchDbModule.ts"],"sourcesContent":["import { gql } from 'apollo-server-core'\n\nexport const base = {\n  typeDefs: gql`\n    scalar JSON\n\n    type Query\n    type Mutation\n  `,\n}\n","import 'isomorphic-fetch'\nimport { CouchDbDocument } from './types'\n\nexport interface CouchDbContext {\n  couchDb: {\n    dbUrl: string\n    dbName: string\n\n    /**\n     * The fetch function used by the requests made to the couchdb server\n     *\n     * default is node-fetch\n     */\n    fetch: typeof fetch\n\n    onResolveConflict?: <T extends CouchDbDocument>(args: {\n      document: T\n      conflicts: T[]\n      context: CouchDbContext\n    }) => T | Promise<T>\n    onConflictsResolved?: <T extends CouchDbDocument>(args: {\n      documents: T[]\n      context: CouchDbContext\n    }) => any\n    onDocumentsSaved?: <T extends CouchDbDocument>(args: {\n      documents: T[]\n      context: CouchDbContext\n    }) => any\n  }\n}\n\nexport function createContext(args: {\n  dbUrl: CouchDbContext['couchDb']['dbUrl']\n  dbName: CouchDbContext['couchDb']['dbName']\n\n  /**\n   * The fetch function used by the requests made to the couchdb server\n   *\n   * default is node-fetch\n   */\n  fetch?: CouchDbContext['couchDb']['fetch']\n\n  onResolveConflict?: CouchDbContext['couchDb']['onResolveConflict']\n  onConflictsResolved?: CouchDbContext['couchDb']['onConflictsResolved']\n  onDocumentsSaved?: CouchDbContext['couchDb']['onDocumentsSaved']\n}): CouchDbContext {\n  return {\n    couchDb: {\n      fetch,\n      ...args,\n    },\n  }\n}\n","import { CouchDbContext } from '../createContext'\nimport { GraphQLFieldResolver } from 'graphql'\n\nexport function createResolverFunction<T = any>(\n  resolver: GraphQLFieldResolver<any, CouchDbContext, T>\n) {\n  return resolver\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export default function parseFetchResponse(response: Response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response.json()\n  } else {\n    const error = new Error(response.statusText)\n\n    // @ts-ignore\n    error.response = response\n    throw error\n  }\n}\n","import { CouchDbContext } from '../createContext'\nimport parseFetchResponse from './parseFetchResponse'\n\n/**\n * Returns an object where the key is the doc id and the value is the rejected document\n * and full conflicting documents\n */\nasync function getConflictsByDocument(\n  documents: any[],\n  context: CouchDbContext\n): Promise<\n  Record<string, { document: any; conflicts: any[]; revToSave: string }>\n> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n\n  // get _conflicts for each document\n  const documentsWithConflictRevs = await fetch(\n    `${dbUrl}/${dbName}/_all_docs?conflicts=true&include_docs=true`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        keys: documents.map(doc => doc._id),\n      }),\n    }\n  )\n    .then(parseFetchResponse)\n    .then(res => {\n      return res.rows.map(row => row.doc).filter(doc => !!doc)\n    })\n\n  // get full document for each _conflict\n  const conflictingDocuments = await fetch(`${dbUrl}/${dbName}/_bulk_get`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      docs: documentsWithConflictRevs.reduce(\n        (conflicts, doc) => [\n          ...conflicts,\n          ...((doc && doc._conflicts) || []).map(rev => ({\n            id: doc._id,\n            rev,\n          })),\n        ],\n        []\n      ),\n    }),\n  })\n    .then(parseFetchResponse)\n    .then(res => res.results.map(row => row.docs[0].ok).filter(doc => !!doc))\n\n  const result = documentsWithConflictRevs.reduce((result, doc) => {\n    if (!result[doc._id]) {\n      const conflictedDoc = documentsWithConflictRevs.find(\n        d => d._id === doc._id\n      )\n\n      result[doc._id] = {\n        // the document rejected by the conflict\n        document: documents.find(original => original._id === doc._id),\n        // all conflicts in the db including the one with _conflicts\n        conflicts: [doc],\n        revToSave: conflictedDoc._rev,\n      }\n    }\n\n    // check if any _conflicts were for this document\n    const conflicts = conflictingDocuments.filter(d => d._id === doc._id)\n\n    if (conflicts) {\n      return {\n        ...result,\n        [doc._id]: {\n          ...result[doc._id],\n          conflicts: [...result[doc._id].conflicts, ...conflicts],\n        },\n      }\n    }\n\n    return result\n  }, {})\n\n  return result\n}\n\n/**\n * Resolves conflicts by calling context.onResolveConflict and saving its result\n */\nexport async function resolveConflicts(\n  documents: any[],\n  context: CouchDbContext\n) {\n  const {\n    fetch,\n    dbName,\n    dbUrl,\n    onResolveConflict,\n    onConflictsResolved,\n  } = context.couchDb\n  if (!onResolveConflict) {\n    return null\n  }\n\n  const conflictingDocuments = await getConflictsByDocument(documents, context)\n\n  const resolvedDocs = await Promise.all(\n    Object.keys(conflictingDocuments).map(async id => {\n      const resolvedDocument = await onResolveConflict!({\n        document: conflictingDocuments[id].document,\n        conflicts: conflictingDocuments[id].conflicts,\n        context,\n      })\n\n      if (!resolvedDocument) {\n        throw new Error('onResolveConflict must return a document')\n      }\n\n      const { _conflicts, ...resolved } = resolvedDocument\n      return {\n        ...resolved,\n        _rev: conflictingDocuments[id].revToSave,\n      }\n    })\n  )\n\n  const docsToSave = [\n    ...resolvedDocs,\n\n    ...Object.keys(conflictingDocuments).reduce(\n      (deleted, docId) => [\n        ...deleted,\n        ...conflictingDocuments[docId].conflicts\n          .map(conflict => ({\n            ...conflict,\n            _deleted: true,\n          }))\n          .filter(\n            conflict => conflict._rev !== conflictingDocuments[docId].revToSave\n          ),\n      ],\n      [] as any[]\n    ),\n  ]\n\n  const response = await fetch(`${dbUrl}/${dbName}/_bulk_docs`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      docs: docsToSave,\n    }),\n  }).then(parseFetchResponse)\n\n  if (onConflictsResolved) {\n    onConflictsResolved({\n      documents: response\n        .filter(result => result.ok)\n        .map(result => ({\n          ...docsToSave.find(doc => doc._id === result.id),\n          _rev: result.rev,\n          _id: result.id,\n        })),\n      context,\n    })\n  }\n  return response\n}\n","import { resolveConflicts } from '../util/resolveConflicts'\nimport { CouchDbDocument } from '../types'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\ninterface PutOptions {\n  upsert?: boolean\n  new_edits?: boolean\n}\n\nexport async function put<T extends CouchDbDocument>(\n  context: CouchDbContext,\n  doc: T,\n  options: PutOptions = {}\n): Promise<T | null> {\n  const { fetch, dbUrl, dbName, onDocumentsSaved } = context.couchDb\n\n  const { upsert, new_edits = true } = options\n  let url = `${dbUrl}/${dbName}/_bulk_docs`\n  let rev = doc._rev\n\n  // get previous _rev for upsert\n  if (upsert) {\n    if (!doc._id) {\n      throw Error('upsert option requires input to contain _id')\n    }\n\n    try {\n      const { _rev } = await fetch(\n        `${dbUrl}/${dbName}/${encodeURIComponent(doc._id)}`\n      ).then(parseFetchResponse)\n      rev = _rev\n    } catch (e) {\n      if (!e.response || e.response.status !== 404) {\n        throw e\n      }\n    }\n  }\n\n  const result = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      docs: [{ ...doc, _rev: rev }],\n      new_edits,\n    }),\n  })\n    .then(parseFetchResponse)\n    .then(async res => {\n      const [result] = res\n\n      // resolve conflicts\n      if (result && result.id && result.error === 'conflict') {\n        const resolved = await resolveConflicts([doc], context)\n\n        return resolved[0]\n      }\n\n      return result\n    })\n\n  if (result && result.error) {\n    throw new Error(result.reason)\n  }\n\n  if (result) {\n    const savedDocument = {\n      ...doc,\n      _id: result.id,\n      _rev: result.rev,\n    }\n\n    if (onDocumentsSaved) {\n      onDocumentsSaved({ documents: [savedDocument], context })\n    }\n\n    return savedDocument\n  } else {\n    // new_edits=false returns empty response\n    return null\n  }\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { put } from '../../couchdb/put'\n\n/**\n * PUTs a document using _bulk_docs endpoint\n */\nexport const typeDefs = gql`\n  type PutResponse {\n    _id: String!\n    _rev: String\n    document: JSON\n  }\n\n  extend type Mutation {\n    put(input: JSON, upsert: Boolean, new_edits: Boolean): PutResponse\n  }\n`\n\nexport const resolvers = {\n  Mutation: {\n    put: createResolverFunction(\n      async (parent, { input, upsert, new_edits = true }, context, info) => {\n        const document = await put(context, input, { upsert, new_edits })\n\n        return {\n          _id: document._id,\n          _rev: document._rev,\n          document,\n        }\n      }\n    ),\n  },\n}\n","import { resolveConflicts } from '../util/resolveConflicts'\nimport { CouchDbDocument } from '../types'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface BulkDocsResponseObject<T extends CouchDbDocument> {\n  _id: string\n  _rev?: string\n  document?: T\n  error?: string\n  reason?: string\n}\n\nexport type BulkDocsResponse<\n  T extends CouchDbDocument\n> = BulkDocsResponseObject<T>[]\n\nexport interface BulkDocsOptions {\n  upsert?: boolean\n  new_edits?: boolean\n}\nexport async function bulkDocs<T extends CouchDbDocument>(\n  context: CouchDbContext,\n  docs: any[],\n  options: BulkDocsOptions = {}\n): Promise<BulkDocsResponse<T>> {\n  const { fetch, dbUrl, dbName, onDocumentsSaved } = context.couchDb\n  const { upsert, new_edits = true } = options\n  let url = `${dbUrl}/${dbName}/_bulk_docs`\n  let previousRevs: Record<string, string> = {}\n\n  // get previous _revs for upsert\n  if (upsert) {\n    const ids: string[] = docs.map(i => i._id).filter(id => !!id)\n\n    const { data: allDocs } = await fetch(`${dbUrl}/${dbName}/_all_docs`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        keys: ids,\n      }),\n    }).then(parseFetchResponse)\n\n    allDocs.rows.forEach(row => {\n      previousRevs[row.id] = row.value ? row.value.rev : null\n    })\n  }\n\n  const saveResults = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      docs: docs.map(doc => ({\n        ...doc,\n        _rev: upsert && doc._id ? previousRevs[doc._id] : doc._rev,\n      })),\n      new_edits,\n    }),\n  })\n    .then(parseFetchResponse)\n    .then(async res => {\n      // resolve conflicts\n      const conflicts = res.filter(result => result.error === 'conflict')\n\n      if (conflicts.length > 0) {\n        const resolved = await resolveConflicts(\n          docs.filter(doc =>\n            conflicts.find(conflict => conflict.id === doc._id)\n          ),\n          context\n        )\n\n        if (resolved) {\n          // update any \"conflict\" results with the resolved result\n          return res.map(saveResult => {\n            const resolvedDoc = resolved.find(\n              resolvedResult => resolvedResult.id === saveResult.id\n            )\n            if (saveResult.error === 'conflict' && resolvedDoc) {\n              return resolvedDoc\n            }\n\n            return saveResult\n          })\n        }\n      }\n\n      // return bulkDocs data\n      return res\n    })\n\n  const response = saveResults.map((result, index) => {\n    const document = docs[index]\n\n    const _rev = result.error\n      ? // if an error, return the last _rev\n        previousRevs[document._id] || document._rev\n      : // otherwise result.rev will be populated\n        result.rev\n\n    return {\n      _id: result.id,\n      _rev,\n      error: result.error,\n      reason: result.reason,\n      document: {\n        ...document,\n        _id: result.id,\n        _rev,\n      },\n    }\n  })\n\n  if (onDocumentsSaved) {\n    onDocumentsSaved({\n      documents: response.filter(res => !res.error).map(res => res.document),\n      context,\n    })\n  }\n\n  return response\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { bulkDocs } from '../../couchdb/bulkDocs'\n\nexport const typeDefs = gql`\n  type BulkDocsResponseObject {\n    _id: String\n    _rev: String\n    document: JSON\n    error: String\n    reason: String\n  }\n\n  extend type Mutation {\n    bulkDocs(\n      input: [JSON!]!\n      upsert: Boolean\n      new_edits: Boolean\n    ): [BulkDocsResponseObject]\n  }\n`\n\nexport const resolvers = {\n  Mutation: {\n    bulkDocs: createResolverFunction(\n      (parent, { input, upsert, new_edits = true }, context, info) => {\n        return bulkDocs(context, input, { upsert, new_edits })\n      }\n    ),\n  },\n}\n","import queryString from 'qs'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface AllDocsOptions {\n  conflicts?: boolean\n  endkey?: any | any[]\n  include_docs?: boolean\n  inclusive_end?: boolean\n  key?: any | any[]\n  keys?: any | any[]\n  limit?: number\n  skip?: number\n  startkey?: any | any[]\n  update_seq?: boolean\n}\n\nexport interface AllDocsResponse<T = any> {\n  total_rows: number\n  offset: number\n  rows: Array<{\n    id: string\n    rev?: string\n    value?: {\n      rev: string\n    }\n    doc?: T\n  }>\n}\n\nexport async function allDocs<T = any>(\n  context: CouchDbContext,\n  { keys, key, endkey, startkey, ...args }: AllDocsOptions = {}\n): Promise<AllDocsResponse<T>> {\n  const { fetch } = context.couchDb\n  let url = `${context.couchDb.dbUrl}/${context.couchDb.dbName}/_all_docs`\n\n  if (args) {\n    url += `?${queryString.stringify(args)}`\n  }\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      keys,\n      key,\n      endkey,\n      startkey,\n    }),\n  }).then(parseFetchResponse)\n\n  return response\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { allDocs } from '../../couchdb/allDocs'\n\nexport const typeDefs = gql`\n  type AllDocsRow {\n    id: String!\n    rev: String\n    value: JSON\n    doc: JSON\n  }\n\n  type AllDocsResponse {\n    total_rows: Int!\n    offset: Int!\n    rows: [AllDocsRow!]!\n  }\n\n  extend type Query {\n    allDocs(\n      conflicts: Boolean\n      endkey: JSON\n      include_docs: Boolean\n      inclusive_end: Boolean\n      key: JSON\n      keys: [JSON!]\n      limit: Int\n      skip: Int\n      startkey: JSON\n      update_seq: Boolean\n    ): AllDocsResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    allDocs: createResolverFunction((parent, args, context, info) => {\n      return allDocs(context, args)\n    }),\n  },\n}\n","import queryString from 'qs'\nimport { CouchDbDocument } from '../types'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface BulkGetOptions {\n  revs?: boolean\n}\n\nexport interface BulkGetResponse<T extends CouchDbDocument> {\n  results: Array<{\n    ok?: T\n    error?: {\n      id: string\n      rev?: string\n      error: string\n      reason: string\n    }\n  }>\n}\n\nexport async function bulkGet<T extends CouchDbDocument>(\n  docs: Array<{ id: string; rev?: string }>,\n  context: CouchDbContext,\n  { revs }: BulkGetOptions = {}\n): Promise<BulkGetResponse<T>> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n  let url = `${dbUrl}/${dbName}/_bulk_get`\n\n  if (revs) {\n    url += `?${queryString.stringify({ revs })}`\n  }\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      docs,\n      revs,\n    }),\n  }).then(parseFetchResponse)\n\n  return response\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { bulkGet } from '../../couchdb/bulkGet'\n\n/**\n * Generic GET on a document\n */\nexport const typeDefs = gql`\n  input BulkGetInput {\n    id: String!\n    rev: String\n  }\n\n  type BulkGetResponse {\n    results: [BulkGetResult!]!\n  }\n\n  type BulkGetResult {\n    id: String\n    docs: [BulkGetDocs!]!\n  }\n\n  type BulkGetDocs {\n    ok: JSON\n    error: BulkGetError\n  }\n\n  type BulkGetError {\n    id: String\n    rev: String\n    error: String\n    reason: String\n  }\n\n  extend type Query {\n    bulkGet(docs: [BulkGetInput!]!, revs: Boolean): BulkGetResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    bulkGet: createResolverFunction((parent, { docs, revs }, context, info) => {\n      return bulkGet(docs, context, { revs })\n    }),\n  },\n}\n","import queryString from 'qs'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface ChangesOptions {\n  doc_ids?: string[]\n  conflicts?: boolean\n  descending?: boolean\n  feed?: string\n  filter?: string\n  heartbeat?: number\n  include_docs?: boolean\n  attachments?: boolean\n  att_encoding_info?: boolean\n  lastEventId?: number\n  limit?: number\n  since?: string | number\n  timeout?: number\n  view?: string\n  seq_interval?: number\n}\n\nexport interface ChangesResponse {\n  last_seq: any\n  pending: number\n  results: Array<{\n    changes: Array<{ rev: string }>\n    id: string\n    seq: any\n    doc: any\n    deleted?: boolean\n  }>\n}\nexport async function changes(\n  context: CouchDbContext,\n  options: ChangesOptions\n): Promise<ChangesResponse> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n  const hasArgs = Object.keys(options).length > 0\n  let url = `${context}/${context}/_changes`\n\n  if (hasArgs) {\n    if (options.lastEventId) {\n      delete options.lastEventId\n      options['last-event-id'] = options.lastEventId\n    }\n\n    // if options.since is not 'now', convert to number\n    if (options.since && options.since !== 'now') {\n      options.since = parseInt(options.since as string)\n    }\n\n    url += `?${queryString.stringify(options)}`\n  }\n\n  const response = await fetch(url).then(parseFetchResponse)\n\n  return response\n}\n","import { gql } from 'apollo-server-core'\n\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { changes } from '../../couchdb/changes'\n\nexport const typeDefs = gql`\n  type Change {\n    rev: String\n  }\n  type ChangesResult {\n    changes: [Change]\n    id: String\n    seq: JSON\n    doc: JSON\n    deleted: Boolean\n  }\n\n  type ChangesResponse {\n    last_seq: JSON\n    pending: Int\n    results: [ChangesResult]\n  }\n\n  extend type Query {\n    changes(\n      doc_ids: [String!]\n      conflicts: Boolean\n      descending: Boolean\n      feed: String\n      filter: String\n      heartbeat: Int\n      include_docs: Boolean\n      attachments: Boolean\n      att_encoding_info: Boolean\n      lastEventId: Int\n      limit: Int\n      since: String\n      timeout: Int\n      view: String\n      seq_interval: Int\n    ): ChangesResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    changes: createResolverFunction((parent, args, context, info) => {\n      return changes(context, args)\n    }),\n  },\n}\n","import parseFetchResponse from '../util/parseFetchResponse'\nimport { CouchDbContext } from '../createContext'\n\nexport interface FindOptions {\n  selector?: any\n  limit?: number\n  skip?: number\n  sort?: number\n  fields?: string[]\n  use_index?: string[]\n  r?: number\n  bookmark?: string\n  update?: boolean\n  stable?: boolean\n  stale?: string\n  execution_stats?: boolean\n}\n\nexport interface FindResponse<T = any> {\n  execution_stats: any\n  bookmark: any\n  warning: string\n  docs: T[]\n}\n\nexport async function find<T = any>(\n  context: CouchDbContext,\n  options: FindOptions\n): Promise<FindResponse<T>> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n  let url = `${dbUrl}/${dbName}/_find`\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(options),\n  }).then(parseFetchResponse)\n\n  return response\n}\n","import queryString from 'qs'\nimport { CouchDbDocument } from '../types'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface GetOptions {\n  rev?: string\n  revs?: boolean\n  revs_info?: boolean\n  open_revs?: boolean\n  conflicts?: boolean\n  attachments?: boolean\n  latest?: boolean\n}\n\nexport async function get<T extends CouchDbDocument>(\n  context: CouchDbContext,\n  id: string,\n  options: GetOptions = {}\n): Promise<T> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n  const hasArgs = Object.keys(options).length > 0\n  let url = `${dbUrl}/${dbName}/${encodeURIComponent(id)}`\n\n  if (hasArgs) {\n    url += `?${queryString.stringify(options)}`\n  }\n\n  const response = await fetch(url).then(parseFetchResponse)\n\n  return response\n}\n","import { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface InfoResponse {\n  db_name: string\n  update_seq: string\n  sizes: {\n    file: number\n    external: number\n    active: number\n  }\n  purge_seq: number\n  other: {\n    data_size: number\n  }\n  doc_del_count: number\n  doc_count: number\n  disk_size: number\n  disk_format_version: number\n  data_size: number\n  compact_running: Boolean\n  cluster: {\n    q: number\n    n: number\n    w: number\n    r: number\n  }\n  instance_start_time: number\n}\n\nexport async function info(context: CouchDbContext): Promise<InfoResponse> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n  let url = `${dbUrl}/${dbName}`\n\n  const response = await fetch(url).then(parseFetchResponse)\n\n  return response\n}\n","import queryString from 'qs'\nimport { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface QueryOptions {\n  ddoc: string\n  view: string\n  conflicts?: boolean\n  descending?: boolean\n  endkey?: any | any[]\n  group?: boolean\n  group_level?: number\n  include_docs?: boolean\n  attachments?: boolean\n  att_encoding_info?: boolean\n  inclusive_end?: boolean\n  key?: any | any[]\n  keys?: any | any[]\n  limit?: number\n  reduce?: boolean\n  skip?: number\n  sorted?: boolean\n  stable?: boolean\n  stale?: string\n  startkey?: any | any[]\n  update?: string\n  update_seq?: boolean\n}\n\nexport interface QueryResponse<T> {\n  offset: number\n  update_seq: any | any[]\n  total_rows: number\n  rows: Array<{\n    id: string\n    key?: any | any[]\n    value?: any\n    doc?: T\n  }>\n}\nexport async function query<T = any>(\n  context: CouchDbContext,\n  { view, ddoc, key, keys, ...options }: QueryOptions\n): Promise<QueryResponse<T>> {\n  const { fetch, dbUrl, dbName, onDocumentsSaved } = context.couchDb\n  const postOptions = { key, keys }\n\n  let url = `${dbUrl}/${dbName}/_design/${ddoc}/_view/${view}`\n\n  if (options) {\n    url += `?${queryString.stringify(options)}`\n  }\n\n  const hasArgs = Object.keys(postOptions).length > 0\n  const fetchOptions: any = {}\n  if (hasArgs) {\n    fetchOptions.method = 'POST'\n    fetchOptions.body = JSON.stringify(postOptions)\n    fetchOptions.headers = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    }\n  }\n\n  const response = await fetch(url, fetchOptions).then(parseFetchResponse)\n\n  return response\n}\n","import { CouchDbContext } from '../createContext'\nimport parseFetchResponse from '../util/parseFetchResponse'\n\nexport interface SearchOptions {\n  index: string\n  ddoc: string\n  query: string\n  bookmark?: string\n  counts?: string[]\n  drilldown?: any\n  group_field?: string\n  group_limit?: number\n  group_sort?: any\n  highlight_fields?: string[]\n  highlight_pre_tag?: string\n  highlight_post_tag?: string\n  highlight_number?: number\n  highlight_size?: number\n  include_docs?: boolean\n  include_fields?: string[]\n  limit?: number\n  ranges?: any\n  sort?: string | string[]\n  stale?: string\n}\n\nexport interface SearchResponse<T> {\n  total_rows: number\n  bookmark: string\n  rows: Array<{\n    id: string\n    order: number[]\n    fields: Record<string, any>\n    doc?: T\n  }>\n  counts?: any\n}\n\nexport async function search<T = any>(\n  context: CouchDbContext,\n  { index, ddoc, ...options }: SearchOptions\n): Promise<SearchResponse<T>> {\n  const { fetch, dbUrl, dbName } = context.couchDb\n\n  let url = `${dbUrl}/${dbName}/_design/${ddoc}/_search/${index}`\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(options),\n  }).then(parseFetchResponse)\n\n  return response\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { find } from '../../couchdb'\n\nexport const typeDefs = gql`\n  type FindResponse {\n    execution_stats: JSON\n    bookmark: String\n    warning: String\n    docs: [JSON!]\n  }\n\n  extend type Query {\n    find(\n      selector: JSON!\n      limit: Int\n      skip: Int\n      sort: Int\n      fields: [String!]\n      use_index: [String!]\n      r: Int\n      bookmark: String\n      update: Boolean\n      stable: Boolean\n      stale: String\n      execution_stats: Boolean\n    ): FindResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    find: createResolverFunction((parent, args, context, info) => {\n      return find(context, args)\n    }),\n  },\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { get } from '../../couchdb'\n\n/**\n * Generic GET on a document\n */\nexport const typeDefs = gql`\n  type GetResponse {\n    _id: String!\n    _rev: String\n    document: JSON\n  }\n\n  extend type Query {\n    get(\n      id: String!\n      rev: String\n      revs: Boolean\n      revs_info: Boolean\n      open_revs: Boolean\n      conflicts: Boolean\n      attachments: Boolean\n      latest: Boolean\n    ): GetResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    get: createResolverFunction(\n      async (parent, { id, ...args }, context, info) => {\n        const document = await get(context, id, args)\n        return {\n          _id: document._id,\n          _rev: document._rev,\n          document,\n        }\n      }\n    ),\n  },\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { info } from '../../couchdb/info'\n\nexport const typeDefs = gql`\n  type Sizes {\n    file: Int\n    external: Int\n    active: Int\n  }\n\n  type Other {\n    data_size: Int\n  }\n\n  type Cluster {\n    q: Int\n    n: Int\n    w: Int\n    r: Int\n  }\n\n  type InfoResponse {\n    db_name: String\n    update_seq: String\n    sizes: Sizes\n    purge_seq: Int\n    other: Other\n    doc_del_count: Int\n    doc_count: Int\n    disk_size: Int\n    disk_format_version: Int\n    data_size: Int\n    compact_running: Boolean\n    cluster: Cluster\n    instance_start_time: Int\n  }\n\n  extend type Query {\n    info: InfoResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    info: createResolverFunction((parent, args, context) => {\n      return info(context)\n    }),\n  },\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { query, QueryOptions } from '../../couchdb/query'\n\nexport const typeDefs = gql`\n  type QueryResponse {\n    offset: Int\n    update_seq: JSON\n    total_rows: Int\n    rows: [QueryRow!]\n  }\n\n  type QueryRow {\n    id: String\n    key: JSON\n    value: JSON\n  }\n\n  extend type Query {\n    query(\n      ddoc: String!\n      view: String!\n      conflicts: Boolean\n      descending: Boolean\n      endkey: JSON\n      group: Boolean\n      group_level: Int\n      include_docs: Boolean\n      attachments: Boolean\n      att_encoding_info: Boolean\n      inclusive_end: Boolean\n      key: JSON\n      keys: [JSON!]\n      limit: Int\n      reduce: Boolean\n      skip: Int\n      sorted: Boolean\n      stable: Boolean\n      stale: String\n      startkey: JSON\n      update: String\n      update_seq: Boolean\n    ): QueryResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    query: createResolverFunction<QueryOptions>(\n      async (parent, args, context, info) => {\n        return query(context, args)\n      }\n    ),\n  },\n}\n","import { gql } from 'apollo-server-core'\nimport { createResolverFunction } from '../../util/createResolverFunction'\nimport { search, SearchOptions } from '../../couchdb/search'\n\nexport const typeDefs = gql`\n  type SearchResponse {\n    total_rows: Int!\n    bookmark: String!\n    rows: [SearchRow]!\n    counts: JSON\n  }\n\n  type SearchRow {\n    id: String!\n    order: [Int!]!\n    fields: JSON!\n    doc: JSON\n  }\n\n  extend type Query {\n    search(\n      index: String!\n      ddoc: String!\n      bookmark: String\n      counts: [String!]\n      drilldown: JSON\n      group_field: String\n      group_limit: Int\n      group_sort: JSON\n      highlight_fields: [String!]\n      highlight_pre_tag: String\n      highlight_post_tag: String\n      highlight_number: Int\n      highlight_size: Int\n      include_docs: Boolean\n      include_fields: [String!]\n      limit: Int\n      query: String!\n      ranges: JSON\n      sort: [String!]\n      stale: String\n    ): SearchResponse\n  }\n`\n\nexport const resolvers = {\n  Query: {\n    search: createResolverFunction<SearchOptions>(\n      async (parent, args, context, info) => {\n        return search(context, args)\n      }\n    ),\n  },\n}\n","import {\n  GraphQLModule,\n  BuildContextFn,\n  GraphQLModuleOptions,\n} from '@graphql-modules/core'\nimport gql from 'graphql-tag'\nimport { CouchDbContext } from './createContext'\nimport * as mutations from './graphql/mutations'\nimport * as queries from './graphql/queries'\nimport { base } from './graphql/base'\n\nexport interface CreateCouchDbModuleArgs<\n  Config,\n  Session extends object,\n  Context extends CouchDbContext = CouchDbContext,\n  SelfResolvers = {}\n>\n  extends Omit<\n    GraphQLModuleOptions<Config, Session, Context, SelfResolvers>,\n    'typeDefs' | 'resolvers'\n  > {\n  cloudant?: boolean\n}\n\nexport function createCouchDbModule<\n  Config,\n  Session extends object,\n  Context extends CouchDbContext = CouchDbContext,\n  SelfResolvers = {}\n>(\n  {\n    cloudant,\n    ...options\n  }: CreateCouchDbModuleArgs<Config, Session, Context, SelfResolvers>,\n  moduleConfig?: Config\n) {\n  const { search, ...couchdbQueries } = queries\n\n  const typeDefs = [\n    base.typeDefs,\n    ...Object.keys(cloudant ? queries : couchdbQueries).map(\n      key => queries[key].typeDefs\n    ),\n    ...Object.keys(mutations).map(key => mutations[key].typeDefs),\n  ]\n\n  const queryResolvers = Object.keys(\n    cloudant ? queries : couchdbQueries\n  ).reduce(\n    (resolvers, key) => ({\n      ...resolvers,\n      ...queries[key].resolvers.Query,\n    }),\n    {}\n  )\n  const mutationResolvers = Object.keys(mutations).reduce(\n    (resolvers, key) => ({\n      ...resolvers,\n      ...mutations[key].resolvers.Mutation,\n    }),\n    {}\n  )\n\n  return new GraphQLModule(\n    {\n      ...options,\n      typeDefs,\n      resolvers: {\n        Query: queryResolvers,\n        Mutation: mutationResolvers,\n      },\n    },\n    moduleConfig\n  )\n}\n"],"names":["base","typeDefs","gql","createContext","args","couchDb","fetch","createResolverFunction","resolver","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","result","e","then","parseFetchResponse","response","status","json","error","Error","statusText","resolveConflicts","documents","context","dbName","dbUrl","onResolveConflict","onConflictsResolved","getConflictsByDocument","conflictingDocuments","Promise","all","Object","keys","map","id","document","conflicts","resolvedDocument","_conflicts","resolved","_rev","revToSave","resolvedDocs","docsToSave","reduce","deleted","docId","conflict","_deleted","filter","method","headers","JSON","stringify","docs","ok","find","doc","_id","rev","res","rows","row","documentsWithConflictRevs","results","conflictedDoc","d","original","put","options","url","new_edits","reason","savedDocument","onDocumentsSaved","upsert","encodeURIComponent","_templateObject","resolvers","Mutation","parent","info","input","bulkDocs","previousRevs","length","saveResult","resolvedDoc","resolvedResult","saveResults","index","ids","i","allDocs","data","forEach","value","key","endkey","startkey","queryString","Query","bulkGet","revs","changes","hasArgs","lastEventId","since","parseInt","get","query","view","ddoc","postOptions","fetchOptions","Accept","search","createCouchDbModule","moduleConfig","cloudant","couchdbQueries","queries","mutations","queryResolvers","mutationResolvers","GraphQLModule"],"mappings":"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"}